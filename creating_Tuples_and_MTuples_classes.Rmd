---
title: "Creating `Tuples` and `MTuples` classes"
author: Peter Hickey
date: 2 April 2014
output:
  html_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(echo = TRUE)
```

# Overview
I want to define a `MTuples` class to store methylation m-tuples, which are the output of my Python program, `comethylation`. The `MTuples` object will need to be able to to store multiple samples in a single object across a set of common tuples. I decided to define the `MTuples` class as an extension to the `SummarizedExperiment` class. The `rowData` of a `SummarizedExperiment` is a GRanges object, which is not suitable for storing m-tuples because m-tuples are "discrete" whereas ranges are "continous".

Therefore, I need to define a `Tuples` class, which extends the `GRanges` class. I will use the `Tuples` class as the `rowData` of a `MTuples` object. This idea was suggested to me by Michael Lawrence (https://stat.ethz.ch/pipermail/bioconductor/attachments/20140323/b8b5fcf2/attachment.pl).

# `Tuples`
An m-tuple consists of `seqname:strand:pos1:pos2:...:posm` (where `:` is used as a delimiter and `...` denotes additional `pos` fields). For example, `chr1:+:56:67:81:90` is a 4-tuple on the positive strand of chromosome 1.

An m-tuple does not naturally fit into a `GRanges` object, which consists of `seqname:strand:start:end` and metadata, but it can be extended upon. The following table displays the relationship between `GRanges` fields and `Tuples` fields. Note that the differences when $m = 1$, $m = 2$ and $m \geq 3$.

 `GRanges`     `Tuples` ($m = 1$)   `Tuples` ($m = 2$)      `Tuples` ($m \geq 3$)
-----------   --------------------- --------------------- ----------------------------
 `seqnames`    `seqnames`                `seqnames`              `seqnames`
 `strand`      `strand`                  `strand`                `strand`
 `start`       `pos1`                    `pos1`                  `pos1`
 `end`         `pos1`                    `pos2`                  `posm`

When $m \geq 3$ we need to also store the "extra" positions (`extraPos`), e.g. `pos2` when $m = 3$. These are stored as "non-optional metadata" via `GenomicRanges:::extraColumnSlotNames`. I'm still figuring out what the best structure is for storing the `extraPos`, e.g. `matrix`, `DataFrame`, `List`, etc.

## Storing `extraPos` as a `DataFrame`
```{r}
library(GenomicRanges)
.Tuples <- setClass('Tuples', contains="GRanges", representation(extraPos = "DataFrame"))
Tuples <- function(extraPos = DataFrame(), seqnames = Rle(), ranges = IRanges(), strand = Rle("*", length(seqnames)), ..., seqlengths = NULL, seqinfo = NULL){
  gr <- GRanges(seqnames = seqnames, ranges = ranges, strand = strand, ..., seqlengths = seqlengths, seqinfo = seqinfo)
  .Tuples(extraPos = extraPos, gr)
  }

## Fix the extraPos column
setMethod(GenomicRanges:::extraColumnSlotNames, "Tuples",
          function(x) {
            c("extraPos")
          })

tuples <- Tuples(extraPos = DataFrame(a = 1:10, b = 10:1), seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, width = 10:1, names = head(letters,10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10), seqinfo = Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1"))
tuples
```
This produces a warning when subsetting but appears to correctly subset the `extraPos` `DataFrame`:
```{r}
tuples[1:3, ]
tuples[1:3, ]@extraPos
```
But definitely "keeps safe" the `extraPos` data:
```{r}
mcols(tuples) <- NULL
tuples
```

## Storing `extraPos` as a `matrix`
```{r}
.Tuples <- setClass('Tuples', contains="GRanges", representation(extraPos = "matrix"))
Tuples <- function(extraPos = matrix(), seqnames = Rle(), ranges = IRanges(), strand = Rle("*", length(seqnames)), ..., seqlengths = NULL, seqinfo = NULL){
  gr <- GRanges(seqnames = seqnames, ranges = ranges, strand = strand, ..., seqlengths = seqlengths, seqinfo = seqinfo)
  .Tuples(extraPos = extraPos, gr)
  }

## Fix the extraPos column
setMethod(GenomicRanges:::extraColumnSlotNames, "Tuples",
          function(x) {
            c("extraPos")
          })

tuples <- Tuples(extraPos = matrix(c(1:10, 10:1), ncol = 2), seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, width = 10:1, names = head(letters,10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10), seqinfo = Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1"))
tuples
```
Subsetting appears to work correctly subset the `extraPos` `matrix`:
```{r}
tuples[1:3, ]
tuples[1:3, ]@extraPos
```
And definitely "keeps safe" the `extraPos` data:
```{r}
mcols(tuples) <- NULL
tuples
```

## Storing `extraPos` as a `List`
`List` objects are a very general class; I have used an `IntegerList` in this example class definition.
```{r}
.Tuples <- setClass('Tuples', contains="GRanges", representation(extraPos = "IntegerList"))
Tuples <- function(extraPos = IntegerList(), seqnames = Rle(), ranges = IRanges(), strand = Rle("*", length(seqnames)), ..., seqlengths = NULL, seqinfo = NULL){
  gr <- GRanges(seqnames = seqnames, ranges = ranges, strand = strand, ..., seqlengths = seqlengths, seqinfo = seqinfo)
  .Tuples(extraPos = extraPos, gr)
  }

## Fix the extraPos column
setMethod(GenomicRanges:::extraColumnSlotNames, "Tuples",
          function(x) {
            c("extraPos")
          })

tuples <- Tuples(extraPos = IntegerList(a = 1:10, b = 10:1), seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, width = 10:1, names = head(letters,10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10), seqinfo = Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1"))
tuples
```
This clearly hasn't worked as I intended:
```{r, error = TRUE}
tuples@extraPos
```
Subsetting doesn't work:
```{r, error = TRUE}
tuples[1:3, ]
tuples[1:3, ]@extraPos
```

## Decision
Using a `matrix` to store the `extraPos` gives the desired behaviour. 

### Additional work
I need to also allow for `extraPos` to be absent, when $m = 1$ or $m = 2$. 

#### `extraPos` as `matrixOrNULL`
I first try this by defining `extraPos` to be a `matrixOrNULL` class union. Unfortunately this doesn't work as expected:
```{r, error = TRUE}
setClassUnion("matrixOrNULL", c("matrix", "NULL"))
.Tuples <- setClass('Tuples', contains="GRanges", representation(extraPos = "matrixOrNULL"))
Tuples <- function(extraPos = matrix(), seqnames = Rle(), ranges = IRanges(), strand = Rle("*", length(seqnames)), ..., seqlengths = NULL, seqinfo = NULL){
  gr <- GRanges(seqnames = seqnames, ranges = ranges, strand = strand, ..., seqlengths = seqlengths, seqinfo = seqinfo)
  .Tuples(extraPos = extraPos, gr)
  } ## FIXME: Constructor explicitly requires extraPos be a matrix

## Fix the extraPos column
setMethod(GenomicRanges:::extraColumnSlotNames, "Tuples",
          function(x) {
            c("extraPos")
          })

tuples_4 <- Tuples(extraPos = matrix(c(1:10, 10:1), ncol = 2, dimnames = list(NULL, c('a', 'b'))), seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, width = 10:1, names = head(letters,10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10), seqinfo = Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1"))
tuples_4
tuples_2 <- Tuples(extraPos = NULL, seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, width = 10:1, names = head(letters,10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10), seqinfo = Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1"))
tuples_2
```
This may be due to the fact the `Tuples` constructor function explicitly calls the `matrix` constructor function, which does not allow for `NULL` values.

#### `extraPos` as `matrix`
Instead, we might just keep `extraPos` as a `matrix` but use the default constructor of a `matrix` when $m = 1$ or $m = 2$, which is a $1 \times 1$ `matrix` with `r NA`:

```{r}
.Tuples <- setClass('Tuples', contains="GRanges", representation(extraPos = "matrix"))
Tuples <- function(extraPos = matrix(), seqnames = Rle(), ranges = IRanges(), strand = Rle("*", length(seqnames)), ..., seqlengths = NULL, seqinfo = NULL){
  gr <- GRanges(seqnames = seqnames, ranges = ranges, strand = strand, ..., seqlengths = seqlengths, seqinfo = seqinfo)
  .Tuples(extraPos = extraPos, gr)
  } 

## Fix the extraPos column
setMethod(GenomicRanges:::extraColumnSlotNames, "Tuples",
          function(x) {
            c("extraPos")
          })

tuples_4 <- Tuples(extraPos = matrix(c(1:10, 10:1), ncol = 2, dimnames = list(NULL, c('a', 'b'))), seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, width = 10:1, names = head(letters,10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10), seqinfo = Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1"))
tuples_4
tuples_2 <- Tuples(extraPos = matrix(), seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, width = 10:1, names = head(letters,10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10), seqinfo = Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1"))
tuples_2
```

But this doesn't allow for subsetting:
```{r, error = TRUE}
tuples_2[1:3, ]
```

## TODOs
* Enforce column names of `extraPos` `matrix`.

# A `show` method for `Tuples`
__TODO__: I'd like to write a `show` method that makes an `Tuples` object look less like a `GRanges` object and more like a `chr:strand:pos1:pos2:..:posm`-format.

# Session info
```{r}
sessionInfo()
```
